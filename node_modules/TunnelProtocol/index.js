var net = require('net'),
    tls = require('tls'),
    spawn = require('child_process').spawn;

module.exports = {
  
  TunnelProtocol: function(socket, config) {
    var tunnelSockets = {};
    
    function pushSocket(tunId, sock) {
      if (! tunnelSockets[tunId]) tunnelSockets[tunId] = [];
      tunnelSockets[tunId].push(sock);
    }
    
    socket.data(['rsvp', 'tunnel-terminate'], function(data) {
      var socks = tunnelSockets[data.tunnelId];
      if (socks) {
        for (var i in socks) {
          if (socks[i].close) socks[i].close();
          if (socks[i].end) socks[i].end();
          if (socks[i].kill) socks[i].kill();
        }
      }
      delete tunnelSockets[data.tunnelId];
    });
    
    socket.data(['rsvp', 'tunnel-request'], function(data) {
      switch (data.direction) {
      case 'server':
      case 'server-once':
        var tunnelLocalServer = net.createServer(function(ssock) {
          ssock.pause();
          pushSocket(data.tunnelId, ssock);
          if (data.direction == 'server-once') tunnelLocalServer.close();
          ssock.on('error', function(err) {
            socket.send(['rsvp', 'client', 'send-message'], {tunnelError:err.toString()});
          });
          var tunnelRemoteStream = tls.connect(config.serverPort+1, config.server, config.tlsParams, function() {
            pushSocket(data.tunnelId, tunnelRemoteStream);
            tunnelRemoteStream.write(data.tunnelId);
            setTimeout(function() {
              tunnelRemoteStream.pipe(ssock);
              ssock.pipe(tunnelRemoteStream);
              ssock.resume();
            }, 500);
          });
          tunnelRemoteStream.on('error', function(err) {
            socket.send(['rsvp', 'client', 'send-message'], {tunnelError:err.toString()});
          });
        }).on('error', function(err) {
          socket.send(['rsvp', 'client', 'send-message'], {tunnelError:err.toString()});
        }).listen(data.port);
        pushSocket(data.tunnelId, tunnelLocalServer);
        console.log("Tunnel listening on port "+data.port);
        break;
      
      case 'connect':
        var tunnelRemoteStream = tls.connect(config.serverPort+1, config.server, config.tlsParams, function() {
          tunnelRemoteStream.write(data.tunnelId);
          var tunnelLocalSocket = net.connect({ port:data.port, host:data.host }, function () {
            
            setTimeout(function() {
              tunnelRemoteStream.pipe(tunnelLocalSocket);
              tunnelLocalSocket.pipe(tunnelRemoteStream);
              tunnelLocalSocket.resume(); //tunnelRemoteStream.resume();
            }, 500);
          });
          tunnelLocalSocket.pause();
          tunnelLocalSocket.on('error', function(err) {
            socket.send(['rsvp', 'client', 'send-message'], {tunnelError:err.toString()});
          });
        });
        //tunnelRemoteStream.pause();
        tunnelRemoteStream.on('error', function(err) {
          socket.send(['rsvp', 'client', 'send-message'], {tunnelError:err.toString()});
        });
        break;
      
      default:
        console.log('Invalid tunnel direction ' + data.direction);
      }
    });
    
    
    socket.data(['rsvp', 'exec'], function(data) {
      var tunnelRemoteStream = tls.connect(config.serverPort+1, config.server, config.tlsParams, function(socket) {
        tunnelRemoteStream.write(data.tunnelId);
        var myENV = process.env;
        if (data.env) { for (var k in data.env) myENV[k] = data.env[k]; }
        var runOptions = data;
        if (data.commandType) runOptions = getCommandByType(data.commandType);
        console.log('Going to run for tunnel: ',runOptions.command,runOptions.args);
        var child = spawn(runOptions.command, runOptions.args, {
          cwd: data.cwd,
          env: myENV
        });
        pushSocket(data.tunnelId, child);
        tunnelRemoteStream.pipe(child.stdin);
        child.stdout.pipe(tunnelRemoteStream);
        child.stderr.pipe(tunnelRemoteStream);
        child.on('exit', function (code, sig) {
          console.log('child process exited with code ' + code);
          if(tunnelRemoteStream.writable) tunnelRemoteStream.write("\n\nchild process exited with code "+code);
          tunnelRemoteStream.end();
        });
        child.on('error', function (error) {
          console.log("error : "+error);
          tunnelRemoteStream.write("\n\nerror : "+error);
          tunnelRemoteStream.end();
        });
      });
      pushSocket(data.tunnelId, tunnelRemoteStream);
      
    });
    
    function getCommandByType(typ) {
      var os = require('os').type();
      switch(typ) {
        case 'shell':
          switch(os) {
            case 'Windows_NT': return {command:'cmd.exe',args:[]};
            default: return {command:'/bin/sh',args:['-i']};
          }
          break;
        case 'vncserver':
          switch(os) {
            case 'Windows_NT': return {command:'tvnserver.exe',args:['-start']};
            case 'Linux': return {command:'x11vnc',args:[]};
          }
      }
    }
    
  }
}