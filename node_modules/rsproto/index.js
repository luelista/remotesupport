var net = require('net'),
        MultiplexStream = require('multiplex-stream'),
        reconnect_inject = require('reconnect-core'),
        tls = require('tls'),
        fs = require('fs'),
        pem = require('pem'),
        events = require('events'),
        ctrlMessage = require('./jsonCtrlMessage');

var reconnect = reconnect_inject(function () {
  // arguments are what you passed to .connect
  return tls.connect.apply(null, arguments);
});

function rsproto(host, port, reconn, key, crt, ca) {
  if (key) key = fs.readFileSync(key);
  if (crt) crt = fs.readFileSync(crt);
  if (ca) ca = fs.readFileSync(ca);
  var caList = ca ? [ca] : null;
  this.seqCounter = 1;
  this.messenger = {};
  this.sequenceCallback = {};
  this.tls_options = {
    host: host,
    port: port,
    key: key,
    cert: crt,

    rejectUnauthorized: ca != null,

    ca: caList
  };
  console.log("Connecting to "+host+":"+port+" ...");
  this.multiplex_options = {
      // The connectTimeout optionally specifies how long to
      // wait in milliseconds for the downstream multiplex to
      // accept connections. It defaults to 3000 milliseconds
      connectTimeout: 5000
  };
  if (reconn) {
    reconnect({}, this.onConnected)
    .on('connect', function (con) {
      // con = underlying connection
      console.log("connect");
    })
    .on('reconnect', function (n, delay) {
      // n = current number of reconnect
      // delay = delay used before reconnect
    })
    .on('disconnect', function (err) {
      // err = possible error
      console.log("disconnect", err);
    })
    .connect(this.tls_options);
  } else {
    var stream=tls.connect(this.tls_options, function() {
      this.onConnected(stream);
    }.bind(this))
    .on("error", function(err) {
      console.log("tls error",err)
    });
  }
}
rsproto.prototype = new events.EventEmitter();

rsproto.prototype.onControlConnection = ctrlMessage.onControlConnection;

rsproto.prototype.onConnected = function(stream) {
  //console.log("Connected");
  this.cleartextStream = stream;
  // stream = the stream you should consume
  this.multiplex = new MultiplexStream(this.multiplex_options, function(upstreamConnection) {
      this.onMultiplexConnection(upstreamConnection);
  }.bind(this));

  this.multiplex.pipe(stream).pipe(this.multiplex);
  this.controlConnection = this.multiplex.connect({
    // optionally specify an id for the stream. By default
    // a v1 UUID will be assigned as the id for anonymous streams
    id: '"ctrl'
  }, function() {
    this.onControlConnection(this.controlConnection);

    this.emit('connected');
  }.bind(this)).on('error', function(error) {
    // timeouts and other errors resulting from connect requests
  });
}

rsproto.prototype.sendMessage = function(mtype, data, callback) {
  var seqnum = null;
  if (callback) {
    seqnum = this.seqCounter++;
    this.sequenceCallback[seqnum] = callback;
  }
  this.controlConnection.write(JSON.stringify([seqnum, null, mtype, data])+"\n");
}

rsproto.prototype.onMultiplexConnection = function(stream) {
  var idm;
  if (idm = stream.id.match(/^forwardOut:([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+):([0-9]+):(.*)$/)) {
    var forwardStream = net.connect(idm[2], idm[1], function() {
      forwardStream.pipe(stream).pipe(forwardStream);
    });
  }
}

rsproto.prototype.close = function() {
  this.sendMessage("goodbye", 0);
  this.controlConnection.end();
  this.cleartextStream.end();
}

rsproto.loadConfig = function(configFile) {
  try {
    return JSON.parse(fs.readFileSync(configFile).toString().replace(/^\s*\/\/.*$/gm,""));
  }Â catch(e) { console.log("Unable to read config from "+configFile+": ",e); return {}; }
}

module.exports = rsproto;
