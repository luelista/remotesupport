var net = require('net'),
        MultiplexStream = require('multiplex-stream'),
        reconnect_inject = require('reconnect-core'),
        tls = require('tls'),
        fs = require('fs'),
        pem = require('pem'),
        events = require('events'),
        ctrlMessage = require('./jsonCtrlMessage');
var spawn = require('child_process').spawn;

var reconnect = reconnect_inject(function () {
  // arguments are what you passed to .connect
  return tls.connect.apply(null, arguments);
});

function rsproto(host, port, reconn, key, crt, ca) {
  if (key) key = fs.readFileSync(key);
  if (crt) crt = fs.readFileSync(crt);
  if (ca) ca = fs.readFileSync(ca);
  var caList = ca ? [ca] : null;
  this.seqCounter = 1;
  this.messenger = {};
  this.sequenceCallback = {};
  this.tls_options = {
    host: host,
    port: port,
    key: key,
    cert: crt,

    rejectUnauthorized: ca != null,

    ca: caList
  };
  console.log("Connecting to "+host+":"+port+" ...");
  this.multiplex_options = {
      // The connectTimeout optionally specifies how long to
      // wait in milliseconds for the downstream multiplex to
      // accept connections. It defaults to 3000 milliseconds
      connectTimeout: 5000
  };
  if (reconn) {
    reconnect({}, this.onConnected)
    .on('connect', function (con) {
      // con = underlying connection
      console.log("connect");
    })
    .on('reconnect', function (n, delay) {
      // n = current number of reconnect
      // delay = delay used before reconnect
    })
    .on('disconnect', function (err) {
      // err = possible error
      console.log("disconnect", err);
    })
    .connect(this.tls_options);
  } else {
    var stream=tls.connect(this.tls_options, function() {
      this.onConnected(stream);
    }.bind(this))
    .on("error", function(err) {
      console.log("tls error",err)
    });
  }
}
rsproto.prototype = new events.EventEmitter();

rsproto.prototype.onControlConnection = ctrlMessage.onControlConnection;

rsproto.prototype.onConnected = function(stream) {
  //console.log("Connected");
  this.cleartextStream = stream;
  // stream = the stream you should consume
  this.multiplex = new MultiplexStream(this.multiplex_options, function(upstreamConnection) {
      this.onMultiplexConnection(upstreamConnection);
  }.bind(this));

  this.multiplex.pipe(stream).pipe(this.multiplex);
  this.controlConnection = this.multiplex.connect({
    // optionally specify an id for the stream. By default
    // a v1 UUID will be assigned as the id for anonymous streams
    id: '"ctrl'
  }, function() {
    this.onControlConnection(this.controlConnection);

    this.emit('connected');
  }.bind(this)).on('error', function(error) {
    // timeouts and other errors resulting from connect requests
  });
}

rsproto.prototype.sendMessage = function(mtype, data, callback) {
  var seqnum = null;
  if (callback) {
    seqnum = this.seqCounter++;
    this.sequenceCallback[seqnum] = callback;
  }
  this.controlConnection.write(JSON.stringify([seqnum, null, mtype, data])+"\n");
}

rsproto.prototype.onMultiplexConnection = function(stream) {
  var idm;
  if (idm = stream.id.match(/^:[^:]+:forwardOut:([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+):([0-9]+):(.*)$/)) {
    var forwardStream = net.connect(idm[2], idm[1], function() {
      forwardStream.pipe(stream).pipe(forwardStream);
    });
  }
  if (idm = stream.id.match(/^:[^:]+:exec:(.*)$/)) {
    //var parm = idm[1].split(':');
    var child = spawn(idm[1]);
    stream.write("Child spawned\n");
    stream.pipe(child.stdin);
    child.stdout.pipe(stream);
    child.stderr.pipe(stream);
    child.on('exit', function(code, signal) {
      stream.write("\nChild process exited with code "+code+", signal "+signal+"\n");
      //stream.flush();
      stream.end();
    });
  }
}

rsproto.prototype.createTunnel = function(toId, parameters, onConnect, onError, forceUseProxy) {
  var self = this;
  conn.once('msg:on_forward_error', function(errMes) {
    console.log("ERROR:",errMes);
  });
  conn.sendMessage('tunnel_broker:connect', { target: toId, parameters: parameters, forceProxy: forceUseProxy }, function(err, info) {
    function success(conn) {
      console.log("tunnel created");
      onConnect(conn);
    }
    function allFailed() {
      if (!forceUseProxy)
        self.createTunnel(toId, parameters, onConnect, onError, true);
      else
        onError("proxy connect failed");
    }
    if (info.tryDirectConnect) {
      var connTrials = [], ok = false;
      for(var i in info.endpoints) {
        connTrials[i] = net.connect(info.endpoints.port, info.endpoints.ip, function() {
          if (ok) { this.end(); return; }
          ok = true;
          success(this);
          console.log("success: "+this);
        }.bind(connTrials[i])).on('error', function() {
          console.log("fail: ");
        });
      }
    } else {
      var upstream = conn.multiplex.connect({
        id: 'T:'+info.tunnelId
      }, function() {
        success(upstream);
      }.bind(this)).on('error', function(error) {
        // timeouts and other errors resulting from connect requests
        console.log("multiplex connection error!");
        allFailed();
      });
    }
  });

}

rsproto.prototype.close = function() {
  this.sendMessage("goodbye", 0);
  this.controlConnection.end();
  this.cleartextStream.end();
}

rsproto.loadConfig = function(configFile) {
  try {
    return JSON.parse(fs.readFileSync(configFile).toString().replace(/^\s*\/\/.*$/gm,""));
  }Â catch(e) { console.log("Unable to read config file: ",e.toString()); return {}; }
}

module.exports = rsproto;
