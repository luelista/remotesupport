var net = require('net'),
        MultiplexStream = require('multiplex-stream'),
        reconnect_inject = require('reconnect-core'),
        tls = require('tls'),
        fs = require('fs'),
        pem = require('pem'),
        events = require('events'),
        util = require('util'),
        ctrlMessage = require('./jsonCtrlMessage');
var spawn = require('child_process').spawn;

var RS_PROTO_VERSION = "0.0.2";

var reconnect = reconnect_inject(function () {
  // arguments are what you passed to .connect
  return tls.connect.apply(null, arguments);
});

function rsproto(host, port, userAgent, reconn, key, crt, ca) {
  if (key) key = fs.readFileSync(key);
  if (crt) crt = fs.readFileSync(crt);
  if (ca) ca = fs.readFileSync(ca);
  var caList = ca ? [ca] : null;
  this.seqCounter = 1;
  this.messenger = {};
  this.tunnelIdParams = {};
  this.sequenceCallback = {};
  this.userAgent = userAgent + "; rsProto "+RS_PROTO_VERSION;
  this.tls_options = {
    host: host,
    port: port,
    key: key,
    cert: crt,

    rejectUnauthorized: ca != null,

    ca: caList
  };
  console.log("Connecting to "+host+":"+port+" ...");
  this.multiplex_options = {
      // The connectTimeout optionally specifies how long to
      // wait in milliseconds for the downstream multiplex to
      // accept connections. It defaults to 3000 milliseconds
      connectTimeout: 5000
  };
  if (reconn) {
    reconnect({}, this.onConnected)
    .on('connect', function (con) {
      // con = underlying connection
      console.log("connect");
    })
    .on('reconnect', function (n, delay) {
      // n = current number of reconnect
      // delay = delay used before reconnect
    })
    .on('disconnect', function (err) {
      // err = possible error
      console.log("disconnect", err);
    })
    .connect(this.tls_options);
  } else {
    var stream=tls.connect(this.tls_options, function() {
      this.onConnected(stream);
    }.bind(this))
    .on("error", function(err) {
      console.log("tls error",err)
    });
  }
}
util.inherits(rsproto, events.EventEmitter);

rsproto.prototype.onControlConnection = ctrlMessage.onControlConnection;

rsproto.prototype.onConnected = function(stream) {
  //console.log("Connected");
  this.cleartextStream = stream;
  // stream = the stream you should consume
  this.multiplex = new MultiplexStream(this.multiplex_options, function(upstreamConnection) {
      this.onMultiplexConnection(upstreamConnection);
  }.bind(this));

  this.multiplex.pipe(stream).pipe(this.multiplex);
  this.controlConnection = this.multiplex.connect({
    // optionally specify an id for the stream. By default
    // a v1 UUID will be assigned as the id for anonymous streams
    id: '"ctrl'
  }, function() {
    this.onControlConnection(this.controlConnection);
    this.sendMessage('client_hello', {client:this.userAgent});
    this.emit('connected');
  }.bind(this)).on('error', function(error) {
    // timeouts and other errors resulting from connect requests
  });

  this.on('msg:tunnel:set_tunnel_params', function(data) {
    this.tunnelIdParams[data.tunnelId] = data;
  }.bind(this));
}

rsproto.prototype.sendMessage = function(mtype, data, callback) {
  var seqnum = null;
  if (callback) {
    seqnum = this.seqCounter++;
    this.sequenceCallback[seqnum] = callback;
  }
  this.controlConnection.write(JSON.stringify([seqnum, null, mtype, data])+"\n");
}

rsproto.prototype.onMultiplexConnection = function(stream) {
  var idm;
  if (idm = stream.id.match(/^T:([0-9]+)$/)) {
    var tunnelInfo = this.tunnelIdParams[idm[1]];
    if (!tunnelInfo) { stream.write("Invalid Tunnel ID "+idm[1]+"<\n"); stream.end(); return; }

    switch(tunnelInfo.type) {
      case 'forward':
        var forwardStream = net.connect(tunnelInfo.port, tunnelInfo.host, function() {
          forwardStream.pipe(stream).pipe(forwardStream);
        });
        break;
      case 'exec':
        var child = spawn(tunnelInfo.cmd, tunnelInfo.args);
        stream.write("[ ] Child spawned\n");
        stream.pipe(child.stdin);
        child.stdout.pipe(stream);
        child.stderr.pipe(stream);
        child.on('exit', function(code, signal) {
          stream.write("\n[ ] Child process exited with code "+code+", signal "+signal+"\n");
          //stream.flush();
          stream.end();
        });
    }

  }
}

rsproto.prototype.createTunnel = function(toId, parameters, onConnect, onError, forceUseProxy) {
  var self = this;
  self.once('msg:on_forward_error', function(errMes) {
    console.log("[!] ERROR:",errMes);
  });
  self.sendMessage('tunnel_broker:connect', { targetId: toId, parameters: parameters, forceProxy: forceUseProxy }, function(err, info) {
    if (err) { onError(err); return; }
    function success(conn) {
      console.log("tunnel created");
      onConnect(conn);
    }
    function allFailed() {
      if (!forceUseProxy)
        self.createTunnel(toId, parameters, onConnect, onError, true);
      else
        onError("proxy connect failed");
    }
    if (info.tryDirectConnect) {
      var connTrials = [], ok = false;
      for(var i in info.endpoints) {
        connTrials[i] = net.connect(info.endpoints.port, info.endpoints.ip, function() {
          if (ok) { this.end(); return; }
          ok = true;
          success(this);
          console.log("[ ] success: "+this);
        }.bind(connTrials[i])).on('error', function() {
          console.log("[!] fail: ");
        });
      }
    } else {
      console.log("connecting multiplex")
      var upstream = self.multiplex.connect({
        id: 'T:'+info.tunnelId
      }, function() {
        success(upstream);
      }.bind(this)).on('error', function(error) {
        // timeouts and other errors resulting from connect requests
        console.log("[!] multiplex connection error!");
        allFailed();
      });
    }
  });

}

rsproto.prototype.close = function() {
  this.sendMessage("goodbye", 0);
  this.controlConnection.end();
  this.cleartextStream.end();
}

rsproto.loadConfig = function(configFile) {
  try {
    return JSON.parse(fs.readFileSync(configFile).toString().replace(/^\s*\/\/.*$/gm,""));
  } catch(e) { console.log("[!] Unable to read config file: ",e.toString()); return {}; }
}

rsproto.getUserHome = function() {
  return process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;
}


module.exports = rsproto;
